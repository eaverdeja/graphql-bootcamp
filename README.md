# GraphQL Bootcamp - Authentication

- [Authentication](#authentication)
  - [Protecting the Prisma API](#protecting-the-prisma-api)
  - [JWT authentication workflow](#jwt-authentication-workflow)
  - [Protecting our Queries and Mutations](#protecting-our-queries-and-mutations)    

## Authentication

### Protecting the Prisma API

The first step we should take in order to secure our API should be restricting access to our Prisma API. By adding a `secret` field to `prisma.yml` we can achieve that. 

<details><summary>prisma.yml</summary>
<p>

```yaml
endpoint: http://localhost:4466
datamodel: datamodel.prisma
secret: somethingsupersecret
```

</p>
</details>

However, we still need to access the Prisma API from inside of our Node app. By adding the same `secret` informed in `prisma.yml` as we create the prisma instance we got that covered.

`prisma.js`

```javascript
import { Prisma } from 'prisma-binding'

const prisma = new Prisma({
  typeDefs: 'src/generated/schema.graphql',
  endpoint: 'http://localhost:4466',
  secret: 'somethingsupersecret'
})

export default prisma
```

We also need to create an extension point on `.graphqlconfig.yaml` so we can still use `graphql get-schema` to get our generated schema. Notice the `prisma` entry in the `extensions`. The `default` endpoint is our autogenerated Prisma API. The `app` endpoint is our custom Node app driven by the `prisma-binding`.

<details><summary>.graphqlconfig.yaml</summary>
<p>

```yaml
projects:
  graphql-bootcamp:
    schemaPath: 'src/generated/schema.graphql'
    extensions:
      prisma: prisma/prisma.yml
      endpoints:
        default:
          url: 'http://localhost:4466/'
          subscription: 'ws://localhost:4466/'
        app:
          url: 'http://localhost:4000/'
          subscription: 'ws://localhost:4000/'
```

</p>
</details>

### JWT authentication workflow

For managing user authentication, JWT was chosen as the tool for the job. JWTs are awesome and are pretty solid in most of the popular languages. The tokens carry a **payload** that can be **decoded by anyone** and are **signed with a secret** only known to the server of the token, so **generating** and **validating** tokens is a breeze ðŸ’¨

The `login` mutation:
> This takes care of the **validation** part

```graphql
  login(credentials: LoginCredentials!): AuthPayload!

  input LoginCredentials {
    email: String!
    password: String!
  }

  type AuthPayload {
    user: User!
    token: String!
  }
```

<details><summary>The resolver function</summary>
<p>

```javascript
async login(
  parent,
  {
    credentials: { email, password }
  },
  { prisma },
  info
) {
  const user = await prisma.query.user({
    where: {
      email
    }
  })
  const hashedPassword = user ? user.password : ''

  const matchPassword = await bcrypt.compare(password, hashedPassword)

  if (!user || !matchPassword) {
    throw new Error('Invalid credentials!')
  }

  return {
    user,
    // createToken() keeps the JWT related stuff out of our resolvers
    // We just need to give it a payload
    token: createToken({ userId: user.id })
  }
}

```

</p>
</details>

---

The return value of the `createUser` mutation also needs to return `AuthPayload` - `createUser` would probably be used in a user signup context. Given that, we need to give the new user a token so he can continue acting as himself.

```graphql
createUser(data: CreateUserInput!): AuthPayload!
```

<details><summary>The resolver function</summary>
<p>

```javascript
async createUser(parent, { data }, { prisma }, info) {
  const { password } = data
  if (password.length < 8) {
    throw new Error('Password must be 8 characters or longer.')
  }

  const hashedPassword = await bcrypt.hash(password, 10)

  const user = await prisma.mutation.createUser({
    data: {
      ...data,
      password: hashedPassword
    }
  })

  return {
    user,
    token: createToken({ userId: user.id })
  }
}

```

</p>
</details>

---

The `createToken` utility used in the resolvers above is pretty simple. It just signs our payload with a well kept and strong secret using the [popular `jsonwebtoken` package](https://www.npmjs.com/package/jsonwebtoken)

`createToken()` keeps the JWT related stuff out of our resolvers. We just need to give it a payload ðŸŽ‰

```javascript
export const createToken = payload => jwt.sign(payload, JWT_SECRET)
```

### Protecting our Queries and Mutations

Being to able to extract the current user's ID from the incoming request was the first step in making sure our queries and mutations would operate properly. This was added to an `auth` utility file together with `createToken()`.

`getUserId()` is able to recover the authorization token both from HTTP and websocket requests/connections and accepts an optional `requireAuth` argument for opting out of the error throwing. It defaults to `true`, blocking program execution by throwing an error if the token isn't valid, but passing `false` to `requireAuth` suppresses the error.

<details><summary><code>auth.js</code></summary>
<p>

```javascript
const JWT_SECRET = 'thisisasecret'

export const getUserId = (request, requireAuth = true) => {
  const { request: httpRequest, connection: socket } = request
  const authHeader = httpRequest
    ? httpRequest.headers.authorization
    : socket.context.Authorization

  if (authHeader) {
    const token = authHeader.replace('Bearer ', '')
    const decoded = jwt.verify(token, JWT_SECRET)

    return decoded.userId
  }

  if (requireAuth) {
    throw new Error('No auth token was given')
  }

  return null
}

...
```

</p>
</details>

This was injected via context, making it available to any resolver.

<details><summary>Injecting on the context</summary>
<p>

```javascript
import {
  getUserId,
  createToken,
  hashPassword,
  comparePassword
} from './utils/auth'

new GraphQLServer({
  typeDefs: './src/schema.graphql',
  resolvers,
  context(request) {
    return {
      prisma,
      request,
      auth: {
        getUserId,
        createToken
      }
    }
  }
})
```

</p>
</details>


<details><summary><code>Mutation.js</code></summary>
<p>

```javascript
createPost(
  parent,
  { data },
  {
    prisma,
    request,
    auth: { getUserId }
  },
  info
) {
  const userId = getUserId(request)

  const { title, body, published } = data
  return prisma.mutation.createPost(
    {
      data: {
        title,
        body,
        published,
        author: {
          connect: {
            id: userId
          }
        }
      }
    },
    info
  )
}
```

</p>
</details>

Utility files were also created for the `Post` and `Comment` types. These files export functions that encapsulate some of the Prisma functionality and error handling, keeping our resolver DRY.

<details><summary><code>utils/post.js</code></summary>
<p>

```javascript
import { getUserId } from './auth'

export const postBelongsToUser = async (postId, prisma, request) => {
  const userId = getUserId(request)

  const match = await prisma.exists.Post({
    id: postId,
    author: {
      id: userId
    }
  })

  if (!match) {
    throw new Error("The desired post doesn't belong to the current user")
  }
}

export const isPostPublished = async (prisma, post) =>
  prisma.exists.Post({
    id: post,
    published: true
  })
```

</p>
</details>


These utility functions are injected via context and have a simple use by the resolvers:

<details><summary><code>Mutation.js</code></summary>
<p>

```javascript
async deletePost(
  parent,
  { id },
  {
    prisma,
    request,
    postUtils: { postBelongsToUser }
  },
  info
) {
  await postBelongsToUser(id, prisma, request)

  return prisma.mutation.deletePost({ where: { id } }, info)
}

...

async createComment(
  parent,
  { data },
  {
    prisma,
    request,
    auth: { getUserId },
    postUtils: { isPostPublished }
  },
  info
) {
  const userId = getUserId(request)
  const { text, post } = data

  const currentlyPublished = await isPostPublished(prisma, post)

  if (!currentlyPublished) {
    throw new Error('Post is not published yet!')
  }

  return prisma.mutation.createComment(
    {
      data: {
        text,
        author: {
          connect: {
            id: userId
          }
        },
        post: {
          connect: {
            id: post
          }
        }
      }
    },
    info
  )
}
```

</p>
</details>

Before deleting a post, we check if it belongs to the currently logged in user. The `deletePost` mutation simply `await`s the execution of the `postBelongsToUser` utility function. If no error was thrown, the program can resume it's flow and delete the post. Before creating a comment, we check if the desired post is already published. If it's not, the resolver throws an error.

> I guess these utility functions could live in the type resolvers (`resolvers/Post.js` for example, seen as they are used solely on the resolver functions) and that they should have clearer responsibilities. Should error throwing/handling by done in these utility functions or in the resolvers? Maybe these are `context x project x team` questions and I won't worry so much about them ðŸ˜„
